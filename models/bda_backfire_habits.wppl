// time webppl bda_backfire_habits.wppl --require mht --require utils

var prior_mhiter = 1000
var prior_burn = prior_mhiter/2
var prior_incrOpts = {burn:prior_burn, verbose: true, verboseLag: prior_mhiter/20}
var priorERP = IncrementalMH(priorModel, prior_mhiter, prior_incrOpts)


var priorERPobject = _.object(map(function(i){
	return [i, _.object(map(function(q){
			return [q, 	marginalize(priorERP, [i,q])]
		},["habit_rate","habit_strength"]))]
}, items))

// var priorERPobject = _.object(map(function(i){
// 	return [i, _.object(map(function(q){
// 			return [q, 	_.object(map(function(p){
// 				return [p, marginalize(priorERP, [i,q,p])]
// 			}, ["gamma","delta"]))]
// 		},["habit_rate","habit_strength"]))]
// }, items))

// console.log('after prior')

// _.flatten([df,df,df])

// priorERPobject

// // priorERPobject["runs"]["habit_strength"]v

var scaleToWindow = {
	"week":7,
	"month":30,
	"year":365,
	"5 years": 365*5
}

// poisson linking function between model posterior on rates (scaled to preferred_window)
var rateLinkingFunction = function(erp, preferred_window){
	return map(function(s){
		var p = Math.exp(erp.score([],s))
		var rate = s*scaleToWindow[preferred_window]
		return {p: p, rate:rate}
	}, erp.support())
}

// d must be in preferred time window
var scoreLinked = function(linked_probs, d){
	return sum(map(function(x){
		return Math.log(x.p*Math.exp(poissonERP.score(x.rate, d)) )
	}, linked_probs))
}

var posteriorBDA = function(){
	var speaker_optimality = uniform(0,20)

	// var action_baserate = uniform(0,0.5)
	// var action_baserate = uniformDraw([0.001,0.01,0.1,0.2])

	// var delta_baserate = uniform(0,20)

	// lambda_backoff = lambda_rate / backoff_scale
	var backoff_scale = uniform(1,10)

	// var utterance_cost = uniform(0, 10)
	var utterance_cost = 1

	// var baserate_component = discretizeBeta(action_baserate, delta_baserate)


	foreach(items, function(i){

		console.log(i)
		var df_item = subset(df, "item", i)
		var preferred_time_window = df_item[0]["pref_window"]

		var backfire_responses = _.pluck(subset(df_item, "condition","communication"), "rounded_ntimes_prefwindow")
		// console.log(i + backfire_responses)
		var observation_responses = _.pluck(subset(df_item, "condition","observation"), "rounded_ntimes_prefwindow")
		var baseline_responses = _.pluck(subset(df_item, "condition","baseline"), "rounded_ntimes_prefwindow")
		// console.log(baseline_responses)

		var habit_rate_params = sample(priorERPobject[i]["habit_rate"])
		var habit_strength_params = sample(priorERPobject[i]["habit_strength"])
		// console.log("before sample prior 0 ")

		// console.log(habit_rate_params)

		var habit_rate = beta(
			shape_alpha(habit_rate_params.gamma,habit_rate_params.delta),
			shape_beta(habit_rate_params.gamma,habit_rate_params.delta)
			)

		// habit_strength_params are on the log (times in 5 years scale)
		// (exp ^ x) / (365*5) to get daily rate
		var lambda_habit = Math.exp(gaussian(
			shape_alpha(habit_strength_params.mu,habit_strength_params.sigma),
			shape_beta(habit_strength_params.mu,habit_strength_params.sigma)
			)) / (365*5)

		var lambda_backoff = lambda_habit / backoff_scale

		// console.log('after sample prior 1')

		// var habit_component = discretizeBeta(habit_strength_params.gamma, habit_strength_params.delta)
		// console.log('after sample prior 2')
		// var habit_rate = sample(priorERPobject[i]["habit_rate"])
		// var habit_strength = sample(priorERPobject[i]["habit_strength"])
		var prior_parameters = {
			habit_rate: habit_rate,
			lambda_habit: lambda_habit,
			lambda_backoff: lambda_backoff,
			cost:utterance_cost
		}
		// console.log("before backfire")
		console.log(prior_parameters)
		var backfireERP = listener1("It happened.", prior_parameters,speaker_optimality)

		var linked_backfire = rateLinkingFunction(backfireERP, preferred_time_window)
		console.log("after backfire")

		var backfiringScr = sum(map(function(d){return scoreLinked(linked_backfire, d)}, backfire_responses))


		// var observationERP = literalBayesian("It happened.",prior_parameters, false)
		// var observationScr = sum(map(function(d){return observationERP.score([], d)}, observation_responses))
		// 	// console.log("after observation")

		// var baselineERP = literalBayesian("It happened.",prior_parameters, true)
		// var baselineScr = sum(map(function(d){return baselineERP.score([], d)}, baseline_responses))
		// // console.log(map(function(s){return [s, Math.exp(baselineERP.score([], s))]}, baselineERP.support()))

	


		// var forcedspeakerERP = nullHypothesis(prior_parameters, speaker_optimality)
		// var forcedspeakerERP = nullListener1("It happened.", prior_parameters, speaker_optimality)
		// // console.log("after forcedspeak")
		// var observationERP = observation("It happened.", prior_parameters)
		// // console.log("after rsa")

		// console.log("after scoring")

		// console.log("backfire score = " +backfiringScr)
		// console.log("observation score = " +observationScr)
		// console.log("baseline score = " +baselineScr)
		// factor(forcedspeakScr)
		factor(backfiringScr)
		// factor(backfiringScr+baselineScr+observationScr)

		query.add(["predictive","communication", i], expectation(backfireERP))

		// query.add(["predictive","baseline", i], expectation(baselineERP))
		
		// query.add(["predictive","observation", i], expectation(observationERP))

	})

	query.add(["parameter", "speaker_optimality", "NA"], speaker_optimality)
	query.add(["parameter", "backoff_scale", "NA"],  backoff_scale)
	// query.add(["parameter", "alternative_rate", "NA"], action_baserate)
	// query.add(["parameter", "alternative_delta", "NA"], delta_baserate)

	return query
}


var mhiter = 1000
var burn = mhiter/2
var incrOpts = {burn:burn, verbose: true, verboseLag: mhiter/20}
var posteriorERP = IncrementalMH(posteriorBDA, mhiter, incrOpts)

console.log("inference complete --- writing to file")
var outFile = "results/bda-backfire-minimal-IncrMH" + mhiter/1000 + "k-b" + burn/1000 + "k" +"_priorMH" + prior_mhiter/1000 + "k-b" + prior_burn/1000 + "ka.csv"
// var outFile = "results/bda-backfire-inferStrengths-IncrMH" + mhiter/1000 + "k-b" + burn/1000 + "k" +"_priorMH" + prior_mhiter/1000 + "k-b" + prior_burn/1000 + "k.csv"
var header = "Type,Condition,Item,Value"

mht.erpWriter(posteriorERP, outFile, header)

console.log("posterior written to " + outFile)