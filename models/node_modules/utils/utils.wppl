var discretizeBeta = function(gamma, delta){
	var shape_alpha =  gamma * delta
	var shape_beta = (1-gamma) * delta
	var betaPDF = function(x){
	  return Math.pow(x,shape_alpha-1)*Math.pow((1-x),shape_beta-1)
	}
	return map(betaPDF, [0.01,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,0.99])
}

var fillArray = function(n, val){
    return repeat(n, function(x){return val})
}

var shape_alpha = function(gamma,delta){return gamma * delta}
var shape_beta = function(gamma,delta){return (1-gamma) * delta}

var avoidEnds = function(response){
    return response<=0 ? 0.001 : response>=1 ? 0.999 : response
}

var discretizeBetaMixture = function(mix, gamma_1, delta_1, gamma_2, delta_2){
	Enumerate(function(){
		return flip(mix) ? discretizeBeta(gamma_1, delta_1) : discretizeBeta(gamma_2, delta_2)
	})
}

var binWidth = 0.5
var minBin = -1
var maxBin = 8

var priorBins = _.range(minBin, maxBin+0.5,binWidth)


var nearestPriorBin = function(x, bins){
  return x > _.max(bins) ? 
      _.max(bins) :
      x < _.min(bins) ? 
      _.min(bins) :
      bins[Math.round(((x - _.min(bins))/(_.max(bins) - _.min(bins)))*(bins.length-1))]
}


var gaussianPMF = function(mu, sigma, bins){
  return map(function(b){return Math.exp(gaussianERP.score([mu, sigma], b))}, bins)
}

var discretizeLogNormalPrior = function(e, mu, sigma){
  Enumerate(function(){
    return flip(e) ? priorBins[discrete(gaussianPMF(mu, sigma, priorBins))] : minBin
  })
}


var discretizeLogNormal1 = function(mu, sigma){
  Enumerate(function(){
  	// var bins = [0.001,0.01,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,
    		// 1.0,1.3,1.6,1.9,2.2,2.5,2.8,3.1,3.4]
  	var bins = [-10,-9.5,-9,-8.5,-8,-7.5,-7,-6.5,-6,-5.5,-5,-4.5,-4,-3.5,-3,
  	-2.5,-2,-1.5,-1,-0.5,0,0.5, 1,1.5,2,2.5,3]

    return Math.exp(bins[discrete(gaussianPMF(mu, sigma, bins))])
  })
}


var discretize2LogNormalPrior = function(e, mix, mu1, sigma1, mu2, sigma2){
  Enumerate(function(){
    return flip(e) ? 
    		flip(mix) ? priorBins[discrete(gaussianPMF(mu1, sigma1, priorBins))] :
			    		priorBins[discrete(gaussianPMF(mu2, sigma2, priorBins))] :  minBin
  })
}


var logistic = function(x, params){
	var scale = params.scale
	var offset = params.offset
	return 1 / (1 + Math.exp(-scale*(x-offset)))
}