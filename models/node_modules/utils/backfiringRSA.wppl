// webppl politeness.wppl --require utils

// a world has both a state and a valence
var worlds = [
	{state: "terrible", valence: 0.01},
	{state: "bad", valence: 0.25},
	{state: "okay", valence: 0.5},
	{state: "good", valence: 0.75},
	{state: "amazing", valence: 0.99}
]

// array of the valence values
var worldValues = _.pluck(worlds, "valence")
var meanWorldValues = _.pluck(worlds, "valence").reverse()

var statePrior = function(){
	return uniformDraw(worlds)
}

var binaryValence = function(world){
	return flip(world.valence)
}

// array of the state values (also the utterances)
var stateValues = _.pluck(worlds, "state")

var utterancePrior = function(){
	return uniformDraw(stateValues)
}

var beingNiceOrMean = function(nice, valence){
	var valenceValues = nice ? worldValues : meanWorldValues
	var i = valenceValues.indexOf(valence)
	var k = nice ? valenceValues.slice(i) : valenceValues.slice(i).reverse()
	// anything of lower valence (for nice) gets low probability
	var weights = append(fillArray(i, 0.0001), k)
	return valenceValues[discrete(weights)]
}

// here, you get the joint goal (communicate state and valence)
// if both kind and honest
// if they're not kind, then the joint goal won't show up
// this will probably lead to the asymmetry, but it's sort of baked in
var qudFunction = function(speakerGoals){
		// idF is function(x){return x}
	return all(idF, _.values(speakerGoals)) ?
			function(w){return w} :
			speakerGoals.honest ? 
				function(w){return w.state} :
				function(w){return w.valence}
}


var politeRSA = function(experimentalCondition, opts, RSAparams, priorParams){

	var stochasticWords = opts.stochasticWords
	var stochasticValence = opts.stochasticValence

	var speakerOptimality = RSAparams.speakerOptimality

	var honestyWeights = discretizeBeta(priorParams.honestGamma, priorParams.honestDelta)
	var kindnessWeights = discretizeBeta(priorParams.kindGamma, priorParams.kindDelta)

	var meaning = stochasticWords ? 
		function(words, state){
			return words=="terrible" ? state == stateValues[discrete([10,1,0.1,0.01,0.001])] : 
					words=="bad" ? state == stateValues[discrete([1,10,1,0.1,0.01])] : 
					words=="okay" ? state == stateValues[discrete([0.1,1,10,1,0.1])] : 
					words=="good" ? state == stateValues[discrete([0.01,0.1,1,10,1])] : 
					words=="amazing" ? state == stateValues[discrete([0.001,0.01,0.1,1,10])] :
					true
		} : 
		function(words, state){
			return words==state
		}

	var listener0 = cache(function(utterance, goals, stochasticWords, stochasticValence) {
	  Enumerate(function(){
	    var world = statePrior()
	    var valence = stochasticValence ? binaryValence(world) : world.valence

	    var m = meaning(utterance, world.state)
	    var binaryWorld = {state: world.state, valence: valence}
	    
	    condition(m) 
	    
	    return qudFunction(goals)(binaryWorld)
	  })
	})


	var speaker1 = cache(function(world, speakerGoals, stochasticWords, stochasticValence) {
	  Enumerate(function(){

	  	var goals = {
	  		honest: flip(speakerGoals.honesty),
	  		kind: flip(speakerGoals.kindness)
	  	}
	    var utterance = utterancePrior()

		// if goal is NOT honesty, then choose world in proportion to valence
	    var valence = goals.honest ? 
	    				world.valence :
	    				beingNiceOrMean(goals.kind, world.valence)

	    var valenceVal = stochasticValence ? flip(valence) : valence

	    // qud either returns true state, or valence, which may or may not be true
	    var qudVal = qudFunction(goals)({"state":world.state, 
		    							"valence":valenceVal})

	    var L0 = listener0(utterance, goals)

	    factor(L0.score([],qudVal))

	    return utterance
	  })
	})


	var listener1 = function(utterance, knowledge, stochasticWords, stochasticValence, priorParams) {
	  Enumerate(function(){
	    var world = statePrior()

	    var speakerGoals = {
	    	honesty: [0.1, 0.3, 0.5, 0.7, 0.9][discrete(honestyWeights)],
	    	kindness: [0.1, 0.3, 0.5, 0.7, 0.9][discrete(kindnessWeights)]
	   	}

	   	condition(knowledge ? knowledge == world.state : true)

	    var S1 = speaker1(world, speakerGoals)

	    factor(speakerOptimality*S1.score([],utterance))

	    return speakerGoals
	  })
	}

	return listener1(experimentalCondition.utterance, 
						experimentalCondition.knowledge, 
						stochasticWords, 
						stochasticValence,
						priorParams)
	// return speaker1({state: "good", valence: 0.75}, {honesty: 0.7, kindness: 0.5}, false, false)
	// return listener0("good", {honest:false, kind: true}, true, true)

}

// var posterior = politeRSA(
// {
// 	utterance: "amazing", 
// 	knowledge: "amazing"
// },
// {
// 	stochasticWords:false, 
// 	stochasticValence:true
// }, 
// {
// 	speakerOptimality:10
// },
// {
// 	honestGamma: 0.5,
// 	honestDelta:2,
// 	kindGamma:0.5, 
// 	kindDelta:2
// })

// console.log("expected honesty " + expectation(marginalizeERP(posterior, "honesty")))
// console.log("expected kindness " + expectation(marginalizeERP(posterior, "kindness")))
